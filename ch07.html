<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 7. React Addons</title><link rel="stylesheet" href="epub.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"/></head><body id="page"><div class="chapter" title="Chapter 7. React Addons"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"></a>Chapter 7. React Addons</h1></div></div></div><p class="it"><a>En el capítulo anterior, hemos aprendido a utilizar React en el lado del servidor. Entendimos la representación previa de los componentes React y los cambios en el ciclo de vida de los componentes cuando se utiliza React en el servidor. También vimos cómo utilizar la API de servidor de React usando Express.js.</a></p>

<p class="p">In the previous chapter, we learned to use React on the server side. We understood pre-rendering of the React components and changes in the component life cycle when using React on server. We also saw how to use server-side API of React using Express.js.</p><p class="it"><a>En este capítulo, vamos a ver React paquetes de complementos de utilidad que no forman parte del núcleo React, sin embargo, se burlan proceso de desarrollo y agradable. Vamos a aprender a utilizar ayudantes inmutabilidad, la clonación de los componentes y utilidades de prueba en este capítulo. No vamos a estar cubriendo otros complementos tales como <code class="literal">Animation</code>, <code class="literal">Perf</code>, y <code class="literal">PureRenderMixin</code>. Estos complementos se tratarán en los siguientes capítulos.</a></p>

<p class="p">In this chapter, we will look at React addons—utility packages that are not a part of React core, however, they make development process fun and enjoyable. We will learn to use immutability helpers, cloning of components, and test utilities in this chapter. We will not be covering other addons such as <code class="literal">Animation</code>, <code class="literal">Perf</code>, and <code class="literal">PureRenderMixin</code>. These addons will be covered in the following chapters.</p><p class="it"><a>En este capítulo, vamos a cubrir los siguientes temas:</a></p>

<p class="p">In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Getting started with React addons</li><li class="listitem" style="list-style-type: disc">Immutability helpers</li><li class="listitem" style="list-style-type: disc">Cloning React components</li><li class="listitem" style="list-style-type: disc">Test helpers</li></ul></div><div class="section" title="Getting started with Addons"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec60"></a>Getting started with Addons</h1></div></div></div><p class="it"><a>Después </a><a id="id173" class="indexterm">de completar el proyecto anterior sobre el uso React en el lado del servidor, el equipo de Mike tiene algo de tiempo libre antes de comenzar el siguiente proyecto. Mike decidió utilizar este tiempo aprendiendo del </a><a id="id174" class="indexterm">React complementos.</a></p>

<p class="p">After <a class="indexterm"></a>completing the previous project about using React on server side, Mike's team got some free time before starting the next project. Mike decided to utilize this time by learning about <a class="indexterm"></a>React addons.</p><p class="it"><a class="indexterm">"Shawn, tenemos algo de tiempo libre. Vamos a utilizar para empezar a trabajar con React complementos."</a></p>

<p class="p">"Shawn, we got some free time. Let's use it to get started with React addons."</p><p class="it"><a class="indexterm">"¿Qué son los complementos React? ¿Están relacionados con React biblioteca central?" pidió a Shawn.</a></p>

<p class="p">"What are React addons? Are they related to React core library?" Shawn asked.</p><p class="it"><a class="indexterm">"React complementos son módulos de servicios públicos que no son una parte de la biblioteca React núcleo. Sin embargo, ellos son bendecidos por el equipo React. En el futuro, algunos de ellos podrían ser incluidos en el núcleo React. Estas bibliotecas proporcionan ayudantes para escribir código inmutable, utilidades para las pruebas React aplicaciones, y las maneras de medir y mejorar el rendimiento de aplicaciones React ". explica Mike.</a></p>

<p class="p">"React addons are utility modules that are not a part of the React core library. However, they are blessed by the React team. In future, some of them might be included in the React core. These libraries provide helpers for writing immutable code, utilities for testing React apps, and ways to measure and improve the performance of React apps." explained Mike.</p><p class="it"><a class="indexterm">"Cada complemento tiene su </a><a id="id175" class="indexterm">propio paquete de NPM, por lo que es de fácil de usar. Por ejemplo, para utilizar el </a><a id="id176" class="indexterm">complemento de actualización, necesitamos instalar y requieren su paquete de NPM."</a></p>

<p class="p">"Each addon has its <a class="indexterm"></a>own npm package, making it to simple to use. For example, to use the <a class="indexterm"></a>Update addon, we need to install and require its npm package."</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>  $ npm install  react-addons-update --save</strong></span>

<span class="strong"><strong>  // src/App.js</strong></span>
<span class="strong"><strong>  import Update from 'react-addons-update';</strong></span>
</pre></div><div class="section" title="Immutability helpers"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec08"></a>Immutability helpers</h2></div></div></div><p class="it"><a>"Shawn, como </a><a id="id177" class="indexterm">estamos aprendiendo acerca de complementos, vamos a añadir la característica de ordenación para </a><a id="id178" class="indexterm">nuestra aplicación para que los usuarios podes ordenar los libros por sus títulos. Ya he añadido el markup requerido para ello."</a></p>

<p class="p">"Shawn, as <a class="indexterm"></a>we are learning about addons, let's add the sorting feature to <a class="indexterm"></a>our app so that the users can sort the books by their titles. I have already added the required markup for it."</p><div class="mediaobject"><img src="graphics/4730_07_01.jpg" alt="Immutability helpers"/></div><p class="it"><a class="indexterm">"¿Se podes tratar de escribir el código para la clasificación cuando un usuario hace clic en el <span class="strong"><strong>título</strong></span> en dirección?" Preguntó Marcos.</a></p>

<p class="p">"Can you try writing the code for sorting when a user clicks on the <span class="strong"><strong>Title</strong></span> heading?" Mark asked.</p><p class="it"><a class="indexterm">"Aquí está. Introduje el estado de clasificación para indicar la dirección de clasificación-ascendente o descendente."</a></p>

<p class="p">"Here it is. I introduced the sorting state to indicate the direction of sorting—ascending or descending."</p><div class="informalexample"><pre class="programlisting">  // Updated getInitialState function of App component
  // src/App.js

  getInitialState(){
    return { books: [],
             totalBooks: 0,
             searchCompleted: false,
             searching: false,
             sorting: 'asc' };
  }</pre></div><p class="it"><a class="indexterm">"Cuando el usuario hace clic en <span class="strong"><strong>el título</strong></span> , será ordenar los libros almacenados en el estado existente en orden ascendente o descendente utilizando el paquete de clasificación por NPM y actualizar el estado con los libros ordenados."</a></p>

  <p class="p">"When the user clicks on <span class="strong"><strong>Title</strong></span>, it will sort the books stored in the existing state in ascending or descending order using the sort-by npm package and update the state with the sorted books."</p><div class="informalexample"><pre class="programlisting">import sortBy from 'sort-by';

_sortByTitle() {
    let sortByAttribute = this.state.sorting === 'asc' ? "title" : "-title";
    let unsortedBooks = this.state.books;
    let sortedBooks = unsortedBooks.sort(sortBy(sortByAttribute));
    this.setState({ books: sortedBooks, 
                    sorting: this._toggleSorting() });
  },

  _toggleSorting() {
    return this.state.sorting === 'asc' ? 'desc' : 'asc';
  }</pre></div><p class="it"><a class="indexterm">"Shawn, esto es funcional, sin embargo, no está siguiendo el camino React React supone que el objeto es inmutable estado Aquí estamos utilizando referencia a los libros de la estatal existente cuando estamos.. </a><a id="id179" class="indexterm">Asignar valor a <code class="literal">unsortedBooks</code>".</a></p>

  <p class="p">"Shawn, this is functional; however, it's not following the React way. React assumes that the state object is immutable. Here we are using reference to the books from the existing state when we are <a class="indexterm"></a>assigning value to <code class="literal">unsortedBooks</code>."</p><div class="informalexample"><pre class="programlisting">let unsortedBooks = this.state.books;</pre></div><p class="it"><a class="indexterm">"Más tarde, estamos mutando </a><a id="id180" class="indexterm">en </a><a class="indexterm">, sin embargo, como efecto secundario, también estamos mutando el valor actual de </a><a class="indexterm">".</a><a class="indexterm"> <code class="literal">unsortedBooks</code><code class="literal">sortedBooks</code><code class="literal">this.state</code></a></p>

  <p class="p">"Later, we are mutating <a class="indexterm"></a>
<code class="literal">unsortedBooks</code> into <code class="literal">sortedBooks</code>; however, as a side-effect, we are also mutating the current value of <code class="literal">this.state</code>."</p><div class="informalexample"><pre class="programlisting">_sortByTitle() {
    let sortByAttribute = this.state.sorting === 'asc' ? "title" : "-title";
    let unsortedBooks = this.state.books;
    console.log("Before sorting :");
    console.log(this.state.books[0].title);
    let sortedBooks = unsortedBooks.sort(sortBy(sortByAttribute));
    console.log("After sorting :");
    console.log(this.state.books[0].title);
    // this.setState({ books: sortedBooks, 
                       sorting: this._toggleSorting() });

  },</pre></div><div class="mediaobject"><img src="graphics/4730_07_02.jpg" alt="Immutability helpers"/></div><p class="it"><a class="indexterm">"Como se podes ver, incluso si comentamos llamada a este. <code class="literal">setState</code>, Nuestro estado actual todavía está mutado." Marcos explicó.</a></p>

  <p class="p">"As you can see, even if we commented call to this.<code class="literal">setState</code>, our current state is still mutated." Mark explained.</p><p class="it"><a class="indexterm">"Esto se podes solucionar fácilmente utilizando <code class="literal">Object.assign</code> desde ES6. Simplemente, podes crear una nueva matriz y copiar el valor actual de <code class="literal">this.state.books</code> en ella. A continuación, podes reordenar la nueva matriz y llamar </a><a id="id181" class="indexterm">a la nueva matriz ordenada." </a><a class="indexterm">Shawn informado.</a><a class="indexterm"> <code class="literal">setState</code></a></p>

  <p class="p">"This can be easily fixed using <code class="literal">Object.assign</code> from ES6. We can simply create a new array and copy the current value of <code class="literal">this.state.books</code> in it. We can then sort the new array and call <a class="indexterm"></a>
<code class="literal">setState</code> with the new sorted array." informed Shawn.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"></a>Note</h3><p class="it"><a>Las <code class="literal">Object.assign</code> método copia los valores de todas las propiedades enumerables de </a><a id="id182" class="indexterm">múltiples objetos de origen en un destino. Más detalles se podes encontrar en la siguiente: </a><a class="ulink" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign</a> .</p>

<p class="p">The <code class="literal">Object.assign</code> method copies the values of all the enumerable properties from <a class="indexterm"></a>multiple source objects in a target. More details can be found at the following: <a class="ulink" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign</a>.</p></div></div><div class="informalexample"><pre class="programlisting">_sortByTitle() {
    let sortByAttribute = this.state.sorting === 'asc' ? "title" : "-title";
    let unsortedBooks = Object.assign([], this.state.books);
    console.log("Before sorting :");
    console.log(this.state.books[0].title);
    let sortedBooks = unsortedBooks.sort(sortBy(sortByAttribute));
    console.log("After sorting :");
    console.log(this.state.books[0].title);
    this.setState({ books: sortedBooks, 
                    sorting: this._toggleSorting() });
  }</pre></div><div class="mediaobject"><img src="graphics/4730_07_03.jpg" alt="Immutability helpers"/></div><p class="it">"Sí. Esto funciona. Sin embargo, el <code class="literal">Object.assign</code> método hará que una copia superficial <code class="literal">this.state.books</code>. Se va a crear un nuevo <code class="literal">unsortedBooks</code> objeto, sin embargo, se seguíá utilizando las mismas referencias de <code class="literal">this.state.books</code> en <code class="literal">unsortedBooks</code>. Digamos que, por alguna razón, queremos que los títulos de todos los libros en en mayúsculas <a id="id183" class="indexterm">las letras, entonces accidentalmente podes mutar </a><a id="id184" class="indexterm">demasiado ", explica Mike.</a><a class="indexterm"> <code class="literal">this.state</code></a></p>

  <p class="p">"Yes. This works. But the <code class="literal">Object.assign</code> method will make a shallow copy of <code class="literal">this.state.books</code>. It will create a new <code class="literal">unsortedBooks</code> object, however, it will still use the same references from <code class="literal">this.state.books</code> in <code class="literal">unsortedBooks</code>. Let's say, for some reason, we want the titles of all books in uppercase <a class="indexterm"></a>letters, then we may accidently mutate <a class="indexterm"></a>
<code class="literal">this.state</code> too," Mike explained.</p><div class="informalexample"><pre class="programlisting">_sortByTitle() {
    let sortByAttribute = this.state.sorting === 'asc' ? "title" : "-title";
    let unsortedBooks = Object.assign([], this.state.books);
    unsortedBooks.map((book) =&gt; book.title = book.title.toUpperCase());
    console.log("unsortedBooks");
    console.log(unsortedBooks[0].title);
    console.log("this.state.books");
    console.log(this.state.books[0].title); 
  }</pre></div><div class="mediaobject"><img src="graphics/4730_07_04.jpg" alt="Immutability helpers"/></div><p class="it"><a class="indexterm">"Como se podes ver, incluso después de usar <code class="literal">Object.assign</code>, <code class="literal">this.state.books</code> aún estaba mutado. En realidad, esto no tiene nada que ver con React como tal. Es debido a la forma JavaScript pasa referencias de matrices y los objetos alrededor. Sin embargo, debido a esto, si tenemos arrays y objetos en nuestro estado profundamente anidado, se hace difícil evitar que las mutaciones ". Mike explica con más detalle.</a></p>

  <p class="p">"As you can see, even after using <code class="literal">Object.assign</code>, <code class="literal">this.state.books</code> was still mutated. Actually, this has nothing to do with React as such. It is due to the way JavaScript passes references of arrays and objects around. However, due to this, if we have arrays and objects in our deeply nested state, it becomes hard to prevent mutations." Mike further explained.</p><p class="it"><a class="indexterm">"¿Siempre tenemos que realizar una copia profunda del objeto de estado para estar en el lado seguro?" pidió a Shawn.</a></p>

  <p class="p">"Do we always have to perform a deep copy of the state object to be on the safer side?" Shawn asked.</p><p class="it"><a class="indexterm">"Bueno, copias profundas podes ser costosos ya veces difícil de lograr con el estado profundamente anidado. Afortunadamente, React proporciona el complemento de actualización con ayudantes inmutabilidad, que podemos utilizar para resolver este problema." Mike añadido.</a></p>

  <p class="p">"Well, deep copies can be expensive and sometimes hard to achieve with deeply nested state. Fortunately, React provides the Update addon with immutability helpers, which we can use to solve this issue." added Mike.</p><p class="it"><a class="indexterm">"Durante el uso de ayudantes inmutabilidad, que necesitamos para responder a las tres preguntas siguientes:"</a></p>

  <p class="p">"While using immutability helpers, we need to answer the following three questions:"</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What needs to be changed?</li><li class="listitem" style="list-style-type: disc">Where it needs to be changed?</li><li class="listitem" style="list-style-type: disc">How it needs to be changed?</li></ul></div><p class="it"><a class="indexterm">"En este caso, tenemos que cambiar el <code class="literal">this.state</code> para mostrar los libros ordenados."</a></p>

  <p class="p">"In this case, we need to change the <code class="literal">this.state</code> to display the sorted books."</p><p class="it"><a class="indexterm">"La segunda cuestión es que en donde debiera ocurrir dentro de la mutación <code class="literal">this.state</code>? La mutación debería ocurrir en <code class="literal">this.state.books</code>".</a></p>

  <p class="p">"The second question is that where should the mutation happen inside <code class="literal">this.state</code>? The mutation should happen in <code class="literal">this.state.books</code>."</p><p class="it"><a class="indexterm">"La tercera pregunta es que cómo debería ocurrir la mutación? ¿Vamos a borrar algo o añadir ningún elemento nuevo o reestructurar los elementos existentes? En este caso, queremos ordenar los elementos como por algún criterio."</a></p>

  <p class="p">"The third question is that how should the mutation happen? Are we going to delete something or add any new element or restructure existing elements? In this case, we want to sort the elements as per some criterion."</p><p class="it"><a class="indexterm">"El complemento de actualización acepta dos parámetros. El primer parámetro es el objeto que queremos mutar. El segundo parámetro nos dónde y cómo debe la mutación tendrá lugar en la primera dice </a><a id="id185" class="indexterm">parámetro. En este caso, queremos mutar <code class="literal">this.state</code>. En <code class="literal">this.state</code>, nos quiere actualizar los libros con los libros ordenados Por lo tanto, nuestro código será similar a la siguiente:".</a></p>

  <p class="p">"The Update addon accepts two parameters. The first parameter is the object that we want to mutate. The second parameter tells us where and how should the mutation take place in the first <a class="indexterm"></a>parameter. In this case, we want to mutate <code class="literal">this.state</code>. In <code class="literal">this.state</code>, we want to update the books with the sorted books. Therefore, our code will look similar to the following:"</p><div class="informalexample"><pre class="programlisting">Update(this.state, { books: { sortedBooks }})</pre></div></div><div class="section" title="Available commands"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec09"></a>Available commands</h2></div></div></div><p class="it"><a>El complemento de actualización </a><a id="id186" class="indexterm">proporciona diferentes comandos para realizar las mutaciones en los arrays y objetos. La sintaxis de estos comandos se inspira en el lenguaje de consulta de MongoDB.</a></p>

  <p class="p">The Update addon <a class="indexterm"></a>provides different commands to perform the mutations in arrays and objects. The syntax of these commands is inspired by MongoDB's query language.</p><p class="it"><a class="indexterm">"La mayoría de estos comandos operan sobre los objetos de matriz que nos permite empujar en una matriz o cancelará el cambio de un elemento de la matriz. También es compatible con la sustitución de la meta en su totalidad mediante el comando set. Aparte de esto, sino que también proporciona el comando de combinación para combinar nuevas claves con un objeto existente ". Mike explicó.</a></p>

  <p class="p">"Most of these commands operate on array objects allowing us to push in an array or unshift an element from the array. It also supports replacing the target entirely using the set command. Other than this, it also provides the merge command to merge new keys with an existing object." Mike explained.</p><p class="it"><a class="indexterm">"Shawn, se aplica mi mando favorito proporcionado por este complemento. Se toma una función y aplica esa función al valor actual del objetivo que se quiere modificar. Se da más flexibilidad para hacer cambios en las estructuras de datos complejas. Es también una insinuar para su siguiente tarea. Trate de utilizar para ordenar los libros por título sin mutar ". Mike desafió.</a></p>

  <p class="p">"Shawn, my favorite command provided by this addon is apply. It takes a function and applies that function to the current value of the target that we want to modify. It gives more flexibility to make changes in the complex data structures. It's also a hint for your next task. Try to use it to sort the books by title without mutating." Mike challenged.</p><p class="it"><a class="indexterm">"Claro. Aquí tienes," dijo Shawn.</a></p>

  <p class="p">"Sure. Here you go," said Shawn.</p><div class="informalexample"><pre class="programlisting">    // src/App.js

import Update from 'react-addons-update';
  
_sortByTitle() {
  let sortByAttribute = this.state.sorting === 'asc' ? "title" : "-title";
  console.log("Before sorting");
  console.log(this.state.books[0].title);
  let newState = Update(this.state,
                        { books: { $apply: (books) =&gt; { return books.sort(sortBy(sortByAttribute)) } },
                          sorting: { $apply: (sorting) =&gt; { return sorting === 'asc' ? 'desc' : 'asc' } } });
  console.log("After sorting");
  console.log(this.state.books[0].title);
  this.setState(newState);
  }</pre></div><div class="mediaobject"><img src="graphics/4730_07_05.jpg" alt="Available commands"/></div><p class="it"><a class="indexterm">"Perfecto, Shawn. Usando </a><a id="id187" class="indexterm">el complemento de actualización hace que sea muy fácil de manejar complejo estado sin llegar a la mutación de la misma."</a></p>

  <p class="p">"Perfect, Shawn. Using <a class="indexterm"></a>the Update addon makes it very easy to manage complex state without actually mutating it."</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"></a>Tip</h3><p class="it"><a>Compruebe </a><a class="ulink" href="https://facebook.github.io/immutable-js/docs/">https://facebook.github.io/immutable-js/docs/</a> para una solución completa para <a id="id188" class="indexterm">el uso de estructuras de datos inmutables en JavaScript.</a></p>

  <p class="p">Check <a class="ulink" href="https://facebook.github.io/immutable-js/docs/">https://facebook.github.io/immutable-js/docs/</a> for a complete solution for <a class="indexterm"></a>using immutable data structures in JavaScript.</p></div></div></div></div></div></body></html>